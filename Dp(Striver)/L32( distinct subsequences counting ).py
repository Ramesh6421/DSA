# Distinct subsequences counting
# problem: link(https://www.codingninjas.com/codestudio/problems/subsequence-counting_3755256?source=youtube&campaign=striver_dp_videos&utm_source=youtube&utm_medium=affiliate&utm_campaign=striver_dp_videos&leftPanelTab=0)
'''
We are given two strings, ‘TEXT' and ‘S’.
We have to calculate the no. of subsequences of ‘TEXT’, which are equal to ‘S’.
Since the answer can be very large print it modulo (10^9)+7.
A Subsequence of a string is the string that is generated by deleting 0 or more letters from the string
and keeping the rest of the letters in the same order.

For Example:
‘TEXT’ = “brootgroot” and ‘S’ = “brt” 
Following subsequences formed by characters at given indices (1-based) of TEXT are counted
1 2 5
1 2 10
1 7 10
So, our output will be:
3

'''
#Recursion + Memoization
'''
TC-> O(N*M)
SC-> O(N*M)+O(N+M)
'''
def count_dist_subseq(i,j,s,t,dp):
    if j<0:
        return 1
    if i<0:
        return 0
    if dp[i][j]!=-1:
        return dp[i][j]
    if s[i]==t[j]:
        dp[i][j]=count_dist_subseq(i-1,j-1,s,t,dp)+count_dist_subseq(i-1,j,s,t,dp)
        return dp[i][j]
    dp[i][j]=count_dist_subseq(i-1,j,s,t,dp)
    return dp[i][j]

s='codingniinjas'
t='in'
n=len(s)
m=len(t)
dp=[[-1 for i in range(m)] for j in range(n)]
print(count_dist_subseq(n-1,m-1,s,t,dp))
    


# 1-based indexing
'''
TC-> O(N*M)
SC-> O(N*M)+O(N+M)
'''
def count_dist_subseq(i,j,s,t,dp):
    if j==0:
        return 1
    if i==0:
        return 0
    if s[i-1]==t[j-1]:
        dp[i][j]=count_dist_subseq(i-1,j-1,s,t,dp)+count_dist_subseq(i-1,j,s,t,dp)
        return dp[i][j]
    dp[i][j]=count_dist_subseq(i-1,j,s,t,dp)
    return dp[i][j]

s='codingniinjas'
t='in'
n=len(s)
m=len(t)
dp=[[-1 for i in range(m+1)] for j in range(n+1)]
print(count_dist_subseq(n,m,s,t,dp))
    

# Tabulation
'''
TC-> O(N*M)
SC-> O(N*M)
'''
def count_dist_subseq(n,m,s,t,dp):
   for i in range(n+1):
       dp[i][0]=1
   for j in range(1,m+1):
       dp[0][j]=0
   for i in range(1,n+1):
       for j in range(1,m+1):
           if s[i-1]==t[j-1]:
               dp[i][j]=dp[i-1][j-1]+dp[i-1][j]
           else:
               dp[i][j]=dp[i-1][j]
   return dp[n][m]

s='codingniinjas'
t='in'
n=len(s)
m=len(t)
dp=[[0 for i in range(m+1)] for j in range(n+1)]
print(count_dist_subseq(n,m,s,t,dp))
    



# Space Optimization using two rows
'''
TC-> O(N*M)
SC-> O(M)
'''
def count_dist_subseq(n,m,s,t,prev):
   prev[0]=1
   for i in range(1,n+1):
       cur=[0 for i in range(m+1)] 
       cur[0]=1
       for j in range(1,m+1):
           if s[i-1]==t[j-1]:
               cur[j]=prev[j-1]+prev[j]
           else:
               cur[j]=prev[j]
       prev=cur        
   return prev[m]            
s='codingniinjas'
t='in'
n=len(s)
m=len(t)
prev=[0 for i in range(m+1)] 
print(count_dist_subseq(n,m,s,t,prev))
    



# Space Optimization using one rows
'''
TC-> O(N*M)
SC-> O(M)
'''
def count_dist_subseq(n,m,s,t,prev):
   prev[0]=1
   for i in range(1,n+1):
       for j in range(m,-1,-1):
           if j>0:
               if s[i-1]==t[j-1]:
                   prev[j]=prev[j-1]+prev[j]
               #else:
                #   prev[j]=prev[j]    
   return prev[m]            
s='codingniinjas'
t='in'
n=len(s)
m=len(t)
prev=[0 for i in range(m+1)] 
print(count_dist_subseq(n,m,s,t,prev))
    
